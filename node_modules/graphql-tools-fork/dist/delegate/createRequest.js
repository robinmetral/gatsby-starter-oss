var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var graphql_1 = require("graphql");
var Interfaces_1 = require("../Interfaces");
var index_1 = require("../utils/index");
function getDelegatingOperation(parentType, schema) {
    if (parentType === schema.getMutationType()) {
        return 'mutation';
    }
    else if (parentType === schema.getSubscriptionType()) {
        return 'subscription';
    }
    return 'query';
}
exports.getDelegatingOperation = getDelegatingOperation;
function createRequestFromInfo(_a) {
    var info = _a.info, schema = _a.schema, _b = _a.operation, operation = _b === void 0 ? getDelegatingOperation(info.parentType, info.schema) : _b, _c = _a.fieldName, fieldName = _c === void 0 ? info.fieldName : _c, args = _a.args, selectionSet = _a.selectionSet, fieldNodes = _a.fieldNodes;
    return createRequest(info.schema, info.fragments, info.operation.variableDefinitions, info.variableValues, schema, operation, fieldName, args, selectionSet, selectionSet != null
        ? undefined
        : fieldNodes != null
            ? fieldNodes
            : info.fieldNodes);
}
exports.createRequestFromInfo = createRequestFromInfo;
function createRequest(sourceSchema, fragments, variableDefinitions, variableValues, targetSchemaOrSchemaConfig, targetOperation, targetField, args, selectionSet, fieldNodes) {
    var argumentNodes;
    var newSelectionSet = selectionSet;
    var newVariableDefinitions = variableDefinitions;
    if (!selectionSet && fieldNodes != null) {
        var selections = fieldNodes.reduce(function (acc, fieldNode) {
            return fieldNode.selectionSet != null
                ? acc.concat(fieldNode.selectionSet.selections)
                : acc;
        }, []);
        newSelectionSet = selections.length
            ? {
                kind: graphql_1.Kind.SELECTION_SET,
                selections: selections,
            }
            : undefined;
        argumentNodes = fieldNodes[0].arguments;
    }
    else {
        argumentNodes = [];
    }
    var variables = {};
    for (var _i = 0, variableDefinitions_1 = variableDefinitions; _i < variableDefinitions_1.length; _i++) {
        var variableDefinition = variableDefinitions_1[_i];
        var varName = variableDefinition.variable.name.value;
        var varType = graphql_1.typeFromAST(sourceSchema, variableDefinition.type);
        variables[varName] = index_1.serializeInputValue(varType, variableValues[varName]);
    }
    if (args != null) {
        var _a = updateArguments(targetSchemaOrSchemaConfig, targetOperation, targetField, argumentNodes, variableDefinitions, variables, args), updatedArguments = _a.arguments, updatedVariableDefinitions = _a.variableDefinitions, updatedVariableValues = _a.variableValues;
        argumentNodes = updatedArguments;
        newVariableDefinitions = updatedVariableDefinitions;
        variables = updatedVariableValues;
    }
    var rootfieldNode = {
        kind: graphql_1.Kind.FIELD,
        alias: null,
        arguments: argumentNodes,
        selectionSet: newSelectionSet,
        name: {
            kind: graphql_1.Kind.NAME,
            value: targetField || fieldNodes[0].name.value,
        },
    };
    var operationDefinition = {
        kind: graphql_1.Kind.OPERATION_DEFINITION,
        operation: targetOperation,
        variableDefinitions: newVariableDefinitions,
        selectionSet: {
            kind: graphql_1.Kind.SELECTION_SET,
            selections: [rootfieldNode],
        },
    };
    var fragmentDefinitions = Object.keys(fragments).map(function (fragmentName) { return fragments[fragmentName]; });
    var document = {
        kind: graphql_1.Kind.DOCUMENT,
        definitions: __spreadArrays([operationDefinition], fragmentDefinitions),
    };
    return {
        document: document,
        variables: variables,
    };
}
exports.createRequest = createRequest;
function updateArguments(subschemaOrSubschemaConfig, operation, fieldName, argumentNodes, variableDefinitions, variableValues, newArgsMap) {
    if (argumentNodes === void 0) { argumentNodes = []; }
    if (variableDefinitions === void 0) { variableDefinitions = []; }
    if (variableValues === void 0) { variableValues = {}; }
    if (newArgsMap === void 0) { newArgsMap = {}; }
    var schema = Interfaces_1.isSubschemaConfig(subschemaOrSubschemaConfig)
        ? subschemaOrSubschemaConfig.schema
        : subschemaOrSubschemaConfig;
    var type;
    if (operation === 'subscription') {
        type = schema.getSubscriptionType();
    }
    else if (operation === 'mutation') {
        type = schema.getMutationType();
    }
    else {
        type = schema.getQueryType();
    }
    var varNames = variableDefinitions.reduce(function (acc, def) {
        acc[def.variable.name.value] = true;
        return acc;
    }, {});
    var numGeneratedVariables = 0;
    var updatedArgs = {};
    argumentNodes.forEach(function (argument) {
        updatedArgs[argument.name.value] = argument;
    });
    var newVariableDefinitions = [];
    var field = type.getFields()[fieldName];
    field.args.forEach(function (argument) {
        if (newArgsMap[argument.name]) {
            var argName = argument.name;
            var varName = void 0;
            do {
                varName = "_v" + (numGeneratedVariables++).toString() + "_" + argName;
            } while (varNames[varName]);
            updatedArgs[argument.name] = {
                kind: graphql_1.Kind.ARGUMENT,
                name: {
                    kind: graphql_1.Kind.NAME,
                    value: argName,
                },
                value: {
                    kind: graphql_1.Kind.VARIABLE,
                    name: {
                        kind: graphql_1.Kind.NAME,
                        value: varName,
                    },
                },
            };
            varNames[varName] = true;
            newVariableDefinitions.push({
                kind: graphql_1.Kind.VARIABLE_DEFINITION,
                variable: {
                    kind: graphql_1.Kind.VARIABLE,
                    name: {
                        kind: graphql_1.Kind.NAME,
                        value: varName,
                    },
                },
                type: astFromType(argument.type),
            });
            variableValues[varName] = index_1.serializeInputValue(argument.type, newArgsMap[argName]);
        }
    });
    return {
        arguments: Object.keys(updatedArgs).map(function (argName) { return updatedArgs[argName]; }),
        variableDefinitions: newVariableDefinitions,
        variableValues: variableValues,
    };
}
function astFromType(type) {
    if (graphql_1.isNonNullType(type)) {
        var innerType = astFromType(type.ofType);
        if (innerType.kind === graphql_1.Kind.NON_NULL_TYPE) {
            throw new Error("Invalid type node " + JSON.stringify(type) + ". Inner type of non-null type cannot be a non-null type.");
        }
        return {
            kind: graphql_1.Kind.NON_NULL_TYPE,
            type: innerType,
        };
    }
    else if (graphql_1.isListType(type)) {
        return {
            kind: graphql_1.Kind.LIST_TYPE,
            type: astFromType(type.ofType),
        };
    }
    return {
        kind: graphql_1.Kind.NAMED_TYPE,
        name: {
            kind: graphql_1.Kind.NAME,
            value: type.name,
        },
    };
}
//# sourceMappingURL=createRequest.js.map